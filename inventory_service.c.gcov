        -:    0:Source:src/backend/database/inventory_service.c
        -:    0:Graph:build_backend_tests/test_inventory_service_real-inventory_service.gcno
        -:    0:Data:build_backend_tests/test_inventory_service_real-inventory_service.gcda
        -:    0:Runs:1
        -:    1:#include "inventory_service.h"
        -:    2:#include "db_connection.h"
        -:    3:#include "logger.h"
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <string.h>
        -:    7:
        -:    8:#ifndef TEST_MODE
        -:    9:
function get_all_inventory called 3 returned 100% blocks executed 78%
        3:   10:int get_all_inventory(InventoryItem *out_items, int max_items)
        -:   11:{
        3:   12:    if (!out_items || max_items <= 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        1:   13:        return 0;
        -:   14:
        2:   15:    DBConnection *conn_wrapper = db_pool_acquire();
call    0 returned 2
        2:   16:    if (!conn_wrapper)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   17:        return 0;
        -:   18:
        1:   19:    const char *query =
        -:   20:        "SELECT id, part_name, sku, quantity, min_stock_level, unit_cost, "
        -:   21:        "to_char(last_restocked_at, 'YYYY-MM-DD HH24:MI:SS') "
        -:   22:        "FROM inventory ORDER BY id ASC;";
        -:   23:
        1:   24:    PGresult *res = PQexec(conn_wrapper->pg_conn, query);
call    0 returned 1
        -:   25:
        1:   26:    if (PQresultStatus(res) != PGRES_TUPLES_OK)
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:   27:    {
    #####:   28:        LOG_ERROR("Failed to fetch inventory: %s",
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   29:                  PQerrorMessage(conn_wrapper->pg_conn));
    #####:   30:        PQclear(res);
call    0 never executed
    #####:   31:        db_pool_release(conn_wrapper);
call    0 never executed
    #####:   32:        return 0;
        -:   33:    }
        -:   34:
        1:   35:    int rows = PQntuples(res);
call    0 returned 1
        1:   36:    int count = (rows < max_items) ? rows : max_items;
        -:   37:
        3:   38:    for (int i = 0; i < count; i++)
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        -:   39:    {
        2:   40:        out_items[i].id = atoi(PQgetvalue(res, i, 0));
call    0 returned 2
call    1 returned 2
        -:   41:
        2:   42:        strncpy(out_items[i].part_name, PQgetvalue(res, i, 1), 99);
call    0 returned 2
        2:   43:        out_items[i].part_name[99] = '\0';
        -:   44:
        2:   45:        strncpy(out_items[i].sku, PQgetvalue(res, i, 2), 49);
call    0 returned 2
        2:   46:        out_items[i].sku[49] = '\0';
        -:   47:
        2:   48:        out_items[i].quantity = atoi(PQgetvalue(res, i, 3));
call    0 returned 2
call    1 returned 2
        2:   49:        out_items[i].min_stock_level = atoi(PQgetvalue(res, i, 4));
call    0 returned 2
call    1 returned 2
        2:   50:        out_items[i].unit_cost = atof(PQgetvalue(res, i, 5));
call    0 returned 2
call    1 returned 2
        -:   51:
        2:   52:        strncpy(out_items[i].last_restocked_at,
        2:   53:                PQgetvalue(res, i, 6), 31);
call    0 returned 2
        2:   54:        out_items[i].last_restocked_at[31] = '\0';
        -:   55:    }
        -:   56:
        1:   57:    PQclear(res);
call    0 returned 1
        1:   58:    db_pool_release(conn_wrapper);
call    0 returned 1
        1:   59:    return count;
        -:   60:}
        -:   61:
function update_inventory_quantity called 1 returned 100% blocks executed 61%
        1:   62:bool update_inventory_quantity(int part_id, int change)
        -:   63:{
        1:   64:    DBConnection *conn_wrapper = db_pool_acquire();
call    0 returned 1
        1:   65:    if (!conn_wrapper)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   66:        return false;
        -:   67:
        -:   68:    char query[256];
        1:   69:    snprintf(query, sizeof(query),
call    0 returned 1
        -:   70:             "UPDATE inventory SET quantity = quantity + (%d) WHERE id = %d;",
        -:   71:             change, part_id);
        -:   72:
        1:   73:    PGresult *res = PQexec(conn_wrapper->pg_conn, query);
call    0 returned 1
        1:   74:    bool success = (PQresultStatus(res) == PGRES_COMMAND_OK);
call    0 returned 1
        -:   75:
        1:   76:    if (!success)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:   77:    {
    #####:   78:        LOG_ERROR("Failed to update inventory: %s",
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   79:                  PQerrorMessage(conn_wrapper->pg_conn));
        -:   80:    }
        -:   81:
        1:   82:    PQclear(res);
call    0 returned 1
        1:   83:    db_pool_release(conn_wrapper);
call    0 returned 1
        1:   84:    return success;
        -:   85:}
        -:   86:
function get_low_stock_items called 1 returned 100% blocks executed 84%
        1:   87:int get_low_stock_items(InventoryItem *out_items, int max_items)
        -:   88:{
        1:   89:    if (!out_items || max_items <= 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
    #####:   90:        return 0;
        -:   91:
        1:   92:    DBConnection *conn_wrapper = db_pool_acquire();
call    0 returned 1
        1:   93:    if (!conn_wrapper)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   94:        return 0;
        -:   95:
        1:   96:    const char *query =
        -:   97:        "SELECT id, part_name, sku, quantity, min_stock_level, unit_cost, "
        -:   98:        "to_char(last_restocked_at, 'YYYY-MM-DD HH24:MI:SS') "
        -:   99:        "FROM inventory WHERE quantity < min_stock_level;";
        -:  100:
        1:  101:    PGresult *res = PQexec(conn_wrapper->pg_conn, query);
call    0 returned 1
        -:  102:
        1:  103:    if (PQresultStatus(res) != PGRES_TUPLES_OK)
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:  104:    {
    #####:  105:        PQclear(res);
call    0 never executed
    #####:  106:        db_pool_release(conn_wrapper);
call    0 never executed
    #####:  107:        return 0;
        -:  108:    }
        -:  109:
        1:  110:    int rows = PQntuples(res);
call    0 returned 1
        1:  111:    int count = (rows < max_items) ? rows : max_items;
        -:  112:
        3:  113:    for (int i = 0; i < count; i++)
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        -:  114:    {
        2:  115:        out_items[i].id = atoi(PQgetvalue(res, i, 0));
call    0 returned 2
call    1 returned 2
        -:  116:
        2:  117:        strncpy(out_items[i].part_name, PQgetvalue(res, i, 1), 99);
call    0 returned 2
        2:  118:        out_items[i].part_name[99] = '\0';
        -:  119:
        2:  120:        strncpy(out_items[i].sku, PQgetvalue(res, i, 2), 49);
call    0 returned 2
        2:  121:        out_items[i].sku[49] = '\0';
        -:  122:
        2:  123:        out_items[i].quantity = atoi(PQgetvalue(res, i, 3));
call    0 returned 2
call    1 returned 2
        2:  124:        out_items[i].min_stock_level = atoi(PQgetvalue(res, i, 4));
call    0 returned 2
call    1 returned 2
        2:  125:        out_items[i].unit_cost = atof(PQgetvalue(res, i, 5));
call    0 returned 2
call    1 returned 2
        -:  126:
        2:  127:        strncpy(out_items[i].last_restocked_at,
        2:  128:                PQgetvalue(res, i, 6), 31);
call    0 returned 2
        2:  129:        out_items[i].last_restocked_at[31] = '\0';
        -:  130:    }
        -:  131:
        1:  132:    PQclear(res);
call    0 returned 1
        1:  133:    db_pool_release(conn_wrapper);
call    0 returned 1
        1:  134:    return count;
        -:  135:}
        -:  136:
        -:  137:#endif  // TEST_MODE
        -:  138:
        -:  139:
        -:  140:// ====================================================================
        -:  141:// MOCK IMPLEMENTATIONS FOR TESTING
        -:  142:// ====================================================================
        -:  143:
        -:  144:#ifdef TEST_MODE
        -:  145:
        -:  146:int get_all_inventory(InventoryItem *items, int max_count)
        -:  147:{
        -:  148:    if (!items || max_count <= 0)
        -:  149:        return 0;
        -:  150:
        -:  151:    items[0].id = 1;
        -:  152:    strcpy(items[0].part_name, "Motor Oil");
        -:  153:    strcpy(items[0].sku, "MO-001");
        -:  154:    items[0].quantity = 50;
        -:  155:    items[0].min_stock_level = 10;
        -:  156:    items[0].unit_cost = 25.5;
        -:  157:    strcpy(items[0].last_restocked_at, "2025-01-01");
        -:  158:
        -:  159:    return 1;
        -:  160:}
        -:  161:
        -:  162:bool update_inventory_quantity(int part_id, int change)
        -:  163:{
        -:  164:    (void)part_id;
        -:  165:    (void)change;
        -:  166:    return true;
        -:  167:}
        -:  168:
        -:  169:int get_low_stock_items(InventoryItem *items, int max_count)
        -:  170:{
        -:  171:    if (!items || max_count <= 0)
        -:  172:        return 0;
        -:  173:
        -:  174:    items[0].id = 2;
        -:  175:    items[0].quantity = 5;
        -:  176:    items[0].min_stock_level = 10;
        -:  177:
        -:  178:    return 1;
        -:  179:}
        -:  180:
        -:  181:#endif
