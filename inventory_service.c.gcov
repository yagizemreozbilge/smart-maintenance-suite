        -:    0:Source:src/backend/database/inventory_service.c
        -:    0:Graph:C:\Users\yagiz\Desktop\Project\smart-maintenance-suite\build_backend_tests\test_inventory_service-inventory_service.gcno
        -:    0:Data:C:\Users\yagiz\Desktop\Project\smart-maintenance-suite\build_backend_tests\test_inventory_service-inventory_service.gcda
        -:    0:Runs:1
        -:    1:#include "inventory_service.h"
        -:    2:#include "db_connection.h"
        -:    3:#include "logger.h"
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <string.h>
        -:    7:
function get_all_inventory called 0 returned 0% blocks executed 0%
    #####:    8:int get_all_inventory(InventoryItem *out_items, int max_items) {
    #####:    9:  DBConnection *conn_wrapper = db_pool_acquire();
call    0 never executed
        -:   10:
    #####:   11:  if (!conn_wrapper) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
        -:   12:
    #####:   13:  const char *query = "SELECT id, part_name, sku, quantity, min_stock_level, unit_cost, "
        -:   14:                      "to_char(last_restocked_at, 'YYYY-MM-DD HH24:MI:SS') FROM inventory ORDER BY id ASC;";
    #####:   15:  PGresult *res = PQexec(conn_wrapper->pg_conn, query);
call    0 never executed
        -:   16:
    #####:   17:  if (PQresultStatus(res) != PGRES_TUPLES_OK) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:   18:    LOG_ERROR("Failed to fetch inventory: %s", PQerrorMessage(conn_wrapper->pg_conn));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
    #####:   19:    PQclear(res);
call    0 never executed
    #####:   20:    db_pool_release(conn_wrapper);
call    0 never executed
    #####:   21:    return 0;
        -:   22:  }
        -:   23:
    #####:   24:  int rows = PQntuples(res);
call    0 never executed
    #####:   25:  int count = (rows < max_items) ? rows : max_items;
        -:   26:
    #####:   27:  for (int i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:   28:    out_items[i].id = atoi(PQgetvalue(res, i, 0));
call    0 never executed
call    1 never executed
    #####:   29:    strncpy(out_items[i].part_name, PQgetvalue(res, i, 1), 99);
call    0 never executed
    #####:   30:    strncpy(out_items[i].sku, PQgetvalue(res, i, 2), 49);
call    0 never executed
    #####:   31:    out_items[i].quantity = atoi(PQgetvalue(res, i, 3));
call    0 never executed
call    1 never executed
    #####:   32:    out_items[i].min_stock_level = atoi(PQgetvalue(res, i, 4));
call    0 never executed
call    1 never executed
    #####:   33:    out_items[i].unit_cost = atof(PQgetvalue(res, i, 5));
call    0 never executed
call    1 never executed
    #####:   34:    strncpy(out_items[i].last_restocked_at, PQgetvalue(res, i, 6), 31);
call    0 never executed
        -:   35:  }
        -:   36:
    #####:   37:  PQclear(res);
call    0 never executed
    #####:   38:  db_pool_release(conn_wrapper);
call    0 never executed
    #####:   39:  return count;
        -:   40:}
        -:   41:
function update_inventory_quantity called 0 returned 0% blocks executed 0%
    #####:   42:bool update_inventory_quantity(int part_id, int change) {
    #####:   43:  DBConnection *conn_wrapper = db_pool_acquire();
call    0 never executed
        -:   44:
    #####:   45:  if (!conn_wrapper) return false;
branch  0 never executed (fallthrough)
branch  1 never executed
        -:   46:
        -:   47:  char query[256];
    #####:   48:  snprintf(query, sizeof(query),
call    0 never executed
        -:   49:           "UPDATE inventory SET quantity = quantity + (%d) WHERE id = %d;",
        -:   50:           change, part_id);
    #####:   51:  PGresult *res = PQexec(conn_wrapper->pg_conn, query);
call    0 never executed
    #####:   52:  bool success = (PQresultStatus(res) == PGRES_COMMAND_OK);
call    0 never executed
        -:   53:
    #####:   54:  if (!success) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:   55:    LOG_ERROR("Failed to update inventory: %s", PQerrorMessage(conn_wrapper->pg_conn));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:   56:  }
        -:   57:
    #####:   58:  PQclear(res);
call    0 never executed
    #####:   59:  db_pool_release(conn_wrapper);
call    0 never executed
    #####:   60:  return success;
        -:   61:}
        -:   62:
function get_low_stock_items called 0 returned 0% blocks executed 0%
    #####:   63:int get_low_stock_items(InventoryItem *out_items, int max_items) {
    #####:   64:  DBConnection *conn_wrapper = db_pool_acquire();
call    0 never executed
        -:   65:
    #####:   66:  if (!conn_wrapper) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
        -:   67:
    #####:   68:  const char *query = "SELECT id, part_name, sku, quantity, min_stock_level, unit_cost, "
        -:   69:                      "to_char(last_restocked_at, 'YYYY-MM-DD HH24:MI:SS') "
        -:   70:                      "FROM inventory WHERE quantity < min_stock_level;";
    #####:   71:  PGresult *res = PQexec(conn_wrapper->pg_conn, query);
call    0 never executed
        -:   72:
    #####:   73:  if (PQresultStatus(res) != PGRES_TUPLES_OK) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####:   74:    PQclear(res);
call    0 never executed
    #####:   75:    db_pool_release(conn_wrapper);
call    0 never executed
    #####:   76:    return 0;
        -:   77:  }
        -:   78:
    #####:   79:  int rows = PQntuples(res);
call    0 never executed
    #####:   80:  int count = (rows < max_items) ? rows : max_items;
        -:   81:
    #####:   82:  for (int i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:   83:    out_items[i].id = atoi(PQgetvalue(res, i, 0));
call    0 never executed
call    1 never executed
    #####:   84:    strncpy(out_items[i].part_name, PQgetvalue(res, i, 1), 99);
call    0 never executed
    #####:   85:    strncpy(out_items[i].sku, PQgetvalue(res, i, 2), 49);
call    0 never executed
    #####:   86:    out_items[i].quantity = atoi(PQgetvalue(res, i, 3));
call    0 never executed
call    1 never executed
    #####:   87:    out_items[i].min_stock_level = atoi(PQgetvalue(res, i, 4));
call    0 never executed
call    1 never executed
    #####:   88:    out_items[i].unit_cost = atof(PQgetvalue(res, i, 5));
call    0 never executed
call    1 never executed
    #####:   89:    strncpy(out_items[i].last_restocked_at, PQgetvalue(res, i, 6), 31);
call    0 never executed
        -:   90:  }
        -:   91:
    #####:   92:  PQclear(res);
call    0 never executed
    #####:   93:  db_pool_release(conn_wrapper);
call    0 never executed
    #####:   94:  return count;
        -:   95:}
        -:   96:
        -:   97:// ====================================================================
        -:   98:// MOCK IMPLEMENTATIONS FOR TESTING
        -:   99:// ====================================================================
        -:  100:
        -:  101:#ifdef TEST_MODE
        -:  102:
        -:  103:int get_all_inventory(InventoryItem *items, int max_count) {
        -:  104:  if (!items || max_count <= 0) return 0;
        -:  105:
        -:  106:  items[0].id = 1;
        -:  107:  strcpy(items[0].name, "Motor Oil");
        -:  108:  items[0].quantity = 25;
        -:  109:  items[0].min_quantity = 10;
        -:  110:  items[1].id = 2;
        -:  111:  strcpy(items[1].name, "Bearings");
        -:  112:  items[1].quantity = 50;
        -:  113:  items[1].min_quantity = 20;
        -:  114:  items[2].id = 3;
        -:  115:  strcpy(items[2].name, "Filters");
        -:  116:  items[2].quantity = 15;
        -:  117:  items[2].min_quantity = 5;
        -:  118:  return 3;
        -:  119:}
        -:  120:
        -:  121:#endif /* TEST_MODE */
