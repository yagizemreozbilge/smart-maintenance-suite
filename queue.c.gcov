        -:    0:Source:src/backend/core/data_structures/queue.c
        -:    0:Graph:C:\Users\yagiz\Desktop\Project\smart-maintenance-suite\build_backend_tests\test_queue-queue.gcno
        -:    0:Data:C:\Users\yagiz\Desktop\Project\smart-maintenance-suite\build_backend_tests\test_queue-queue.gcda
        -:    0:Runs:1
        -:    1:/* This file is a template for queue.c. Content will be filled by yagiz on 2025-12-29. */
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "queue.h"
        -:    5:
        -:    6:// Internal Helper for Mutex
function lockMutex called 9 returned 100% blocks executed 100%
        9:    7:static void lockMutex(Mutex *m) {
        -:    8:#if defined(_WIN32) || defined(_WIN64)
        9:    9:  EnterCriticalSection(m);
call    0 returned 9
        -:   10:#else
        -:   11:  pthread_mutex_lock(m);
        -:   12:#endif
        9:   13:}
        -:   14:
function unlockMutex called 9 returned 100% blocks executed 100%
        9:   15:static void unlockMutex(Mutex *m) {
        -:   16:#if defined(_WIN32) || defined(_WIN64)
        9:   17:  LeaveCriticalSection(m);
call    0 returned 9
        -:   18:#else
        -:   19:  pthread_mutex_unlock(m);
        -:   20:#endif
        9:   21:}
        -:   22:
function initMutex called 2 returned 100% blocks executed 100%
        2:   23:static void initMutex(Mutex *m) {
        -:   24:#if defined(_WIN32) || defined(_WIN64)
        2:   25:  InitializeCriticalSection(m);
call    0 returned 2
        -:   26:#else
        -:   27:  pthread_mutex_init(m, NULL);
        -:   28:#endif
        2:   29:}
        -:   30:
function destroyMutex called 0 returned 0% blocks executed 0%
    #####:   31:static void destroyMutex(Mutex *m) {
        -:   32:#if defined(_WIN32) || defined(_WIN64)
    #####:   33:  DeleteCriticalSection(m);
call    0 never executed
        -:   34:#else
        -:   35:  pthread_mutex_destroy(m);
        -:   36:#endif
    #####:   37:}
        -:   38:
        -:   39:// Function to initialize the queue
function initQueue called 2 returned 100% blocks executed 100%
        2:   40:void initQueue(Queue *q) {
        2:   41:  q->head = 0;
        2:   42:  q->tail = 0;
        2:   43:  q->count = 0;
        -:   44:  // Initialize standard mutex
        2:   45:  initMutex(&q->lock);
call    0 returned 2
        2:   46:}
        -:   47:
        -:   48:// Helper to destroy queue resources
function destroyQueue called 0 returned 0% blocks executed 0%
    #####:   49:void destroyQueue(Queue *q) {
    #####:   50:  destroyMutex(&q->lock);
call    0 never executed
    #####:   51:}
        -:   52:
        -:   53:// Is Queue empty? (Not thread-safe on its own, usually called within lock or for checks)
        -:   54:// But for strict safety, we can lock it too.
function isQueueEmpty called 3 returned 100% blocks executed 100%
        3:   55:bool isQueueEmpty(Queue *q) {
        3:   56:  return (q->count == 0);
        -:   57:}
        -:   58:
        -:   59:// Is Queue full?
function isQueueFull called 2 returned 100% blocks executed 100%
        2:   60:bool isQueueFull(Queue *q) {
        2:   61:  return (q->count == MAX_QUEUE_SIZE);
        -:   62:}
        -:   63:
        -:   64:// Enqueue element (Thread-safe)
function enqueue called 2 returned 100% blocks executed 67%
        2:   65:bool enqueue(Queue *q, SensorData data) {
        2:   66:  lockMutex(&q->lock);
call    0 returned 2
        -:   67:
        2:   68:  if (isQueueFull(q)) {
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:   69:    printf("ERROR: Queue is full! Data lost: %.2f\n", data.value);
call    0 never executed
    #####:   70:    unlockMutex(&q->lock);
call    0 never executed
    #####:   71:    return false;
        -:   72:  }
        -:   73:
        -:   74:  // Write data to tail
        2:   75:  q->items[q->tail] = data;
        -:   76:  // Circular Buffer logic
        2:   77:  q->tail = (q->tail + 1) % MAX_QUEUE_SIZE;
        2:   78:  q->count++;
        2:   79:  unlockMutex(&q->lock);
call    0 returned 2
        2:   80:  return true;
        -:   81:}
        -:   82:
        -:   83:// Dequeue element (Thread-safe)
function dequeue called 3 returned 100% blocks executed 100%
        3:   84:bool dequeue(Queue *q, SensorData *outData) {
        3:   85:  lockMutex(&q->lock);
call    0 returned 3
        -:   86:
        3:   87:  if (isQueueEmpty(q)) {
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        -:   88:    // printf("Queue is empty.\n"); // Logging might be noisy
        1:   89:    unlockMutex(&q->lock);
call    0 returned 1
        1:   90:    return false;
        -:   91:  }
        -:   92:
        -:   93:  // Read data from head
        2:   94:  *outData = q->items[q->head];
        -:   95:  // Circular Buffer logic
        2:   96:  q->head = (q->head + 1) % MAX_QUEUE_SIZE;
        2:   97:  q->count--;
        2:   98:  unlockMutex(&q->lock);
call    0 returned 2
        2:   99:  return true;
        -:  100:}
        -:  101:
function getQueueSize called 4 returned 100% blocks executed 100%
        4:  102:int getQueueSize(Queue *q) {
        -:  103:  int size;
        4:  104:  lockMutex(&q->lock);
call    0 returned 4
        4:  105:  size = q->count;
        4:  106:  unlockMutex(&q->lock);
call    0 returned 4
        4:  107:  return size;
        -:  108:}
