        -:    0:Source:src/backend/core/data_structures/bst.c
        -:    0:Graph:build_backend_tests/test_bst-bst.gcno
        -:    0:Data:build_backend_tests/test_bst-bst.gcda
        -:    0:Runs:1
        -:    1:/* This file is a template for bst.c. Content will be filled by yagiz on 2025-12-29. */
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:#include "bst.h"
        -:    6:
function initBST called 2 returned 100% blocks executed 100%
        2:    7:void initBST(BST *tree) {
        2:    8:  tree->root = NULL;
        2:    9:  tree->count = 0;
        2:   10:}
        -:   11:
        -:   12:// Helper: Create a new node
function createNode called 3 returned 100% blocks executed 60%
        3:   13:static BSTNode *createNode(Machine machine) {
        3:   14:  BSTNode *newNode = (BSTNode *)malloc(sizeof(BSTNode));
        -:   15:
        3:   16:  if (newNode == NULL) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   17:    printf("CRITICAL ERROR: Memory allocation failed!\n");
call    0 never executed
    #####:   18:    return NULL;
        -:   19:  }
        -:   20:
        3:   21:  newNode->data = machine;
        3:   22:  newNode->left = NULL;
        3:   23:  newNode->right = NULL;
        3:   24:  return newNode;
        -:   25:}
        -:   26:
        -:   27:// Helper: Recursive Insert
function insertRecursive called 6 returned 100% blocks executed 100%
        6:   28:static bool insertRecursive(BSTNode **node, Machine machine) {
        -:   29:  // 1. Base Case: Found empty spot
        6:   30:  if (*node == NULL) {
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        3:   31:    *node = createNode(machine);
call    0 returned 3
        3:   32:    return true;
        -:   33:  }
        -:   34:
        -:   35:  // 2. Recursive Step
        3:   36:  if (machine.machine_id < (*node)->data.machine_id) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:   37:    return insertRecursive(&(*node)->left, machine);
call    0 returned 1
        2:   38:  } else if (machine.machine_id > (*node)->data.machine_id) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   39:    return insertRecursive(&(*node)->right, machine);
call    0 returned 1
        -:   40:  } else {
        -:   41:    // 3. Duplicate Case
        1:   42:    printf("ERROR: Machine ID %d already exists! duplicate rejected.\n", machine.machine_id);
call    0 returned 1
        1:   43:    return false;
        -:   44:  }
        -:   45:}
        -:   46:
function insertMachine called 4 returned 100% blocks executed 100%
        4:   47:bool insertMachine(BST *tree, Machine machine) {
        4:   48:  bool success = insertRecursive(&tree->root, machine);
call    0 returned 4
        -:   49:
        4:   50:  if (success) {
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:   51:    tree->count++;
        3:   52:    printf("Inventory Added: %s (ID: %d)\n", machine.name, machine.machine_id);
call    0 returned 3
        -:   53:  }
        -:   54:
        4:   55:  return success;
        -:   56:}
        -:   57:
        -:   58:// Helper: Recursive Search
function searchRecursive called 5 returned 100% blocks executed 83%
        5:   59:static Machine *searchRecursive(BSTNode *node, int id) {
        -:   60:  // Base Case: Empty or Found
        5:   61:  if (node == NULL || node->data.machine_id == id) {
branch  0 taken 4 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 3
        2:   62:    return (node == NULL) ? NULL : &node->data;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:   63:  }
        -:   64:
        -:   65:  // Navigation
        3:   66:  if (id < node->data.machine_id) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   67:    return searchRecursive(node->left, id);
call    0 never executed
        -:   68:  } else {
        3:   69:    return searchRecursive(node->right, id);
call    0 returned 3
        -:   70:  }
        -:   71:}
        -:   72:
function searchMachine called 2 returned 100% blocks executed 100%
        2:   73:Machine *searchMachine(BST *tree, int machine_id) {
        2:   74:  Machine *result = searchRecursive(tree->root, machine_id);
call    0 returned 2
        -:   75:
        2:   76:  if (result) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   77:    printf("FOUND: %s in %s\n", result->name, result->location);
call    0 returned 1
        -:   78:  } else {
        1:   79:    printf("NOT FOUND: Machine ID %d\n", machine_id);
call    0 returned 1
        -:   80:  }
        -:   81:
        2:   82:  return result;
        -:   83:}
        -:   84:
        -:   85:// Helper: In-Order Traversal (L-N-R)
function printRecursive called 0 returned 0% blocks executed 0%
    #####:   86:static void printRecursive(BSTNode *node) {
    #####:   87:  if (node != NULL) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:   88:    printRecursive(node->left);
call    0 never executed
    #####:   89:    printf("[%d] %-20s | Location: %s\n",
    #####:   90:           node->data.machine_id, node->data.name, node->data.location);
call    0 never executed
    #####:   91:    printRecursive(node->right);
call    0 never executed
        -:   92:  }
    #####:   93:}
        -:   94:
function printInventory called 0 returned 0% blocks executed 0%
    #####:   95:void printInventory(BST *tree) {
    #####:   96:  printf("\n--- FACTORY INVENTORY (Sorted by ID) ---\n");
call    0 never executed
    #####:   97:  printRecursive(tree->root);
call    0 never executed
    #####:   98:  printf("----------------------------------------\n");
call    0 never executed
    #####:   99:}
        -:  100:
function destroyRecursive called 7 returned 100% blocks executed 100%
        7:  101:static void destroyRecursive(BSTNode *node) {
        7:  102:  if (node != NULL) {
branch  0 taken 3 (fallthrough)
branch  1 taken 4
        3:  103:    destroyRecursive(node->left);
call    0 returned 3
        3:  104:    destroyRecursive(node->right);
call    0 returned 3
        3:  105:    free(node);
        -:  106:  }
        7:  107:}
        -:  108:
function destroyBST called 1 returned 100% blocks executed 100%
        1:  109:void destroyBST(BST *tree) {
        1:  110:  destroyRecursive(tree->root);
call    0 returned 1
        1:  111:  tree->root = NULL;
        1:  112:  tree->count = 0;
        1:  113:}
